<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>JavaScript Mandelbrot Explorer</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; padding: 5px; background: rgba(0,0,0,0.5); border-radius: 5px; }
    </style>
</head>
<body>
    <canvas id="mandelbrot-canvas"></canvas>
    <div id="info">
        <h2>JavaScript版</h2>
        <p>マウスホイールでズーム、ドラッグで移動</p>
        <p id="zoom-level"></p>
        <p id="iterations-count"></p>
        <p id="render-time"></p> </div>

    <script>
        // Wasmを使わないので、type="module" は不要
        const canvas = document.getElementById('mandelbrot-canvas');
        const ctx = canvas.getContext('2d');
        const zoomLevelEl = document.getElementById('zoom-level');
        const iterationsCountEl = document.getElementById('iterations-count');
        const renderTimeEl = document.getElementById('render-time');

        // --- JavaScriptによる描画関数 ---
        function getColorJS(iteration, maxIterations) {
            if (iteration === maxIterations) {
                return [0, 0, 0]; // Black
            }
            const hue = (360 * iteration / maxIterations) % 360;
            const saturation = 1.0;
            const value = 1.0;

            const c = value * saturation;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = value - c;
            let r_prime, g_prime, b_prime;
            if (hue >= 0 && hue < 60) { [r_prime, g_prime, b_prime] = [c, x, 0]; }
            else if (hue >= 60 && hue < 120) { [r_prime, g_prime, b_prime] = [x, c, 0]; }
            else if (hue >= 120 && hue < 180) { [r_prime, g_prime, b_prime] = [0, c, x]; }
            else if (hue >= 180 && hue < 240) { [r_prime, g_prime, b_prime] = [0, x, c]; }
            else if (hue >= 240 && hue < 300) { [r_prime, g_prime, b_prime] = [x, 0, c]; }
            else { [r_prime, g_prime, b_prime] = [c, 0, x]; }
            
            return [
                (r_prime + m) * 255,
                (g_prime + m) * 255,
                (b_prime + m) * 255,
            ];
        }

        function renderMandelbrotJS(width, height, centerX, centerY, scale, maxIterations) {
            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;
            const aspect = width / height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cx = centerX + (x / width - 0.5) * scale * aspect;
                    const cy = centerY + (y / height - 0.5) * scale;
                    
                    let zx = 0.0;
                    let zy = 0.0;
                    let iteration = 0;
                    
                    while (zx * zx + zy * zy <= 4.0 && iteration < maxIterations) {
                        const temp_zx = zx * zx - zy * zy + cx;
                        zy = 2.0 * zx * zy + cy;
                        zx = temp_zx;
                        iteration++;
                    }

                    const color = getColorJS(iteration, maxIterations);
                    const index = (y * width + x) * 4;
                    pixels[index] = color[0];     // R
                    pixels[index + 1] = color[1]; // G
                    pixels[index + 2] = color[2]; // B
                    pixels[index + 3] = 255;      // Alpha
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // --- メインロジック (Wasm版とほぼ同じ) ---
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', () => {
            resizeCanvas();
            requestDraw();
        });
        resizeCanvas();

        let centerX = -0.75;
        let centerY = 0.0;
        let scale = 3.5;
        let maxIterations = 50;
        let needsRedraw = true;

        const requestDraw = () => { needsRedraw = true; };

        const draw = () => {
            if (!needsRedraw) {
                requestAnimationFrame(draw);
                return;
            }
            needsRedraw = false;
            
            maxIterations = Math.floor(50 + Math.max(0, -Math.log10(scale) * 25));

            const startTime = performance.now(); // 時間計測開始
            
            // Wasmの代わりにJS関数を呼び出す
            renderMandelbrotJS(canvas.width, canvas.height, centerX, centerY, scale, maxIterations);
            
            const endTime = performance.now(); // 時間計測終了

            zoomLevelEl.textContent = `ズーム: x${(1 / scale).toExponential(2)}`;
            iterationsCountEl.textContent = `計算回数: ${maxIterations}`;
            renderTimeEl.textContent = `描画時間: ${(endTime - startTime).toFixed(2)} ms`; // 結果を表示
            
            requestAnimationFrame(draw);
        };

        canvas.addEventListener('wheel', event => {
            event.preventDefault();
            const zoomFactor = event.deltaY < 0 ? 0.90 : 1.10;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const aspect = canvas.width / canvas.height;
            const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
            const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;
            scale *= zoomFactor;
            centerX = pointX - (pointX - centerX) * zoomFactor;
            centerY = pointY - (pointY - centerY) * zoomFactor;
            requestDraw();
        });

        let isDragging = false;
        let lastX, lastY;
        canvas.addEventListener('mousedown', event => { isDragging = true; lastX = event.clientX; lastY = event.clientY; });
        canvas.addEventListener('mousemove', event => {
            if (!isDragging) return;
            const dx = event.clientX - lastX;
            const dy = event.clientY - lastY;
            const aspect = canvas.width / canvas.height;
            centerX -= (dx / canvas.width) * scale * aspect;
            centerY -= (dy / canvas.height) * scale;
            lastX = event.clientX;
            lastY = event.clientY;
            requestDraw();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        draw(); // 描画ループを開始

    </script>
</body>
</html>
