<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>JavaScript Mandelbrot Explorer</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; padding: 5px; background: rgba(0,0,0,0.5); border-radius: 5px; }
    </style>
</head>
<body>
    <canvas id="mandelbrot-canvas"></canvas>
    <div id="info">
        <h2>JavaScript版</h2>
        <p>マウスホイールでズーム、ドラッグで移動</p>
        <p id="zoom-level"></p>
        <p id="iterations-count"></p>
        <p id="render-time"></p>
    </div>
    
    <div id="animation-controls" style="position: absolute; top: 10px; left: 200px; padding: 10px; background: rgba(0,0,0,0.7); border-radius: 5px;">
      <h3>アニメーションズーム</h3>
      <div>
        <label>ターゲット X:</label>
        <input type="text" id="animate-target-x-js" value="0.0">
      </div>
      <div>
        <label>ターゲット Y:</label>
        <input type="text" id="animate-target-y-js" value="0.0">
      </div>
      <div>
        <label>ズームステップ:</label>
        <input type="number" id="animate-steps-js" value="100" min="1">
      </div>
      <div>
        <label>ステップごとのズーム倍率:</label>
        <input type="number" id="animate-zoom-factor-js" value="0.98" min="0.5" max="0.999" step="0.001">
      </div>
      <button id="start-animation-button-js">アニメーション開始</button>
    </div>

    <script>
        // Wasmを使わないので、type="module" は不要
        const canvas = document.getElementById('mandelbrot-canvas');
        const ctx = canvas.getContext('2d');
        const zoomLevelEl = document.getElementById('zoom-level');
        const iterationsCountEl = document.getElementById('iterations-count');
        const renderTimeEl = document.getElementById('render-time');

        // --- JavaScriptによる描画関数 ---
        function getColorJS(iteration, maxIterations) {
            if (iteration === maxIterations) {
                return [0, 0, 0]; // Black
            }
            const hue = (360 * iteration / maxIterations) % 360;
            const saturation = 1.0;
            const value = 1.0;

            const c = value * saturation;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = value - c;
            let r_prime, g_prime, b_prime;
            if (hue >= 0 && hue < 60) { [r_prime, g_prime, b_prime] = [c, x, 0]; }
            else if (hue >= 60 && hue < 120) { [r_prime, g_prime, b_prime] = [x, c, 0]; }
            else if (hue >= 120 && hue < 180) { [r_prime, g_prime, b_prime] = [0, c, x]; }
            else if (hue >= 180 && hue < 240) { [r_prime, g_prime, b_prime] = [0, x, c]; }
            else if (hue >= 240 && hue < 300) { [r_prime, g_prime, b_prime] = [x, 0, c]; }
            else { [r_prime, g_prime, b_prime] = [c, 0, x]; }
            
            return [
                (r_prime + m) * 255,
                (g_prime + m) * 255,
                (b_prime + m) * 255,
            ];
        }

        function renderMandelbrotJS(width, height, centerX, centerY, scale, maxIterations) {
            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;
            const aspect = width / height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cx = centerX + (x / width - 0.5) * scale * aspect;
                    const cy = centerY + (y / height - 0.5) * scale;
                    
                    let zx = 0.0;
                    let zy = 0.0;
                    let iteration = 0;
                    
                    while (zx * zx + zy * zy <= 4.0 && iteration < maxIterations) {
                        const temp_zx = zx * zx - zy * zy + cx;
                        zy = 2.0 * zx * zy + cy;
                        zx = temp_zx;
                        iteration++;
                    }

                    const color = getColorJS(iteration, maxIterations);
                    const index = (y * width + x) * 4;
                    pixels[index] = color[0];     // R
                    pixels[index + 1] = color[1]; // G
                    pixels[index + 2] = color[2]; // B
                    pixels[index + 3] = 255;      // Alpha
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // --- メインロジック (Wasm版とほぼ同じ) ---
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', () => {
            resizeCanvas();
            requestDraw();
        });
        resizeCanvas();

        let centerX = -0.75;
        let centerY = 0.0;
        let scale = 3.5;
        let maxIterations = 50;
        let needsRedraw = true;

        const requestDraw = () => { needsRedraw = true; };

        const draw = () => {
            if (!needsRedraw) {
                requestAnimationFrame(draw);
                return;
            }
            needsRedraw = false;
            
            maxIterations = Math.floor(50 + Math.max(0, -Math.log10(scale) * 25));

            const startTime = performance.now(); // 時間計測開始
            
            // Wasmの代わりにJS関数を呼び出す
            renderMandelbrotJS(canvas.width, canvas.height, centerX, centerY, scale, maxIterations);
            
            const endTime = performance.now(); // 時間計測終了

            zoomLevelEl.textContent = `ズーム: x${(1 / scale).toExponential(2)}`;
            iterationsCountEl.textContent = `計算回数: ${maxIterations}`;
            renderTimeEl.textContent = `描画時間: ${(endTime - startTime).toFixed(2)} ms`; // 結果を表示
            
            requestAnimationFrame(draw);
        };

        let animationIntervalIdJS = null;
        let animationStepJS = 0;
        let targetCenterXJS = 0.0;
        let targetCenterYJS = 0.0;
        let totalStepsJS = 100;
        let zoomFactorPerStepJS = 0.98;

        const startAnimationJS = () => {
            targetCenterXJS = parseFloat(document.getElementById('animate-target-x-js').value);
            targetCenterYJS = parseFloat(document.getElementById('animate-target-y-js').value);
            totalStepsJS = parseInt(document.getElementById('animate-steps-js').value, 10);
            zoomFactorPerStepJS = parseFloat(document.getElementById('animate-zoom-factor-js').value);
            animationStepJS = 0;

            if (isNaN(targetCenterXJS) || isNaN(targetCenterYJS) || isNaN(totalStepsJS) || isNaN(zoomFactorPerStepJS) || totalStepsJS <= 0 || zoomFactorPerStepJS <= 0 || zoomFactorPerStepJS >= 1) {
                alert("アニメーション設定が無効です。");
                return;
            }

            if (animationIntervalIdJS) {
                clearInterval(animationIntervalIdJS);
                animationIntervalIdJS = null;
            }

            animationIntervalIdJS = setInterval(() => {
                if (animationStepJS < totalStepsJS) {
                    const aspect = canvas.width / canvas.height;
                    const deltaX = targetCenterXJS - centerX;
                    const deltaY = targetCenterYJS - centerY;

                    centerX += deltaX * 0.05;
                    centerY += deltaY * 0.05;

                    scale *= zoomFactorPerStepJS;
                    requestDraw();
                    animationStepJS++;
                } else {
                    clearInterval(animationIntervalIdJS);
                    animationIntervalIdJS = null;
                    console.log("JSアニメーション終了");
                }
            }, 30);
        };

        document.getElementById('start-animation-button-js').addEventListener('click', startAnimationJS);
        
        canvas.addEventListener('wheel', event => {
            event.preventDefault();
            const zoomFactor = event.deltaY < 0 ? 0.90 : 1.10;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const aspect = canvas.width / canvas.height;
            const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
            const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;
            scale *= zoomFactor;
            centerX = pointX - (pointX - centerX) * zoomFactor;
            centerY = pointY - (pointY - centerY) * zoomFactor;
            requestDraw();
        });

        let isDragging = false;
        let lastX, lastY;
        canvas.addEventListener('mousedown', event => { isDragging = true; lastX = event.clientX; lastY = event.clientY; });
        canvas.addEventListener('mousemove', event => {
            if (!isDragging) return;
            const dx = event.clientX - lastX;
            const dy = event.clientY - lastY;
            const aspect = canvas.width / canvas.height;
            centerX -= (dx / canvas.width) * scale * aspect;
            centerY -= (dy / canvas.height) * scale;
            lastX = event.clientX;
            lastY = event.clientY;
            requestDraw();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        canvas.addEventListener('click', (event) => {
            // 1. マウスのキャンバス上の座標を取得
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // 2. キャンバス座標を複素平面上の座標に変換 (既存のロジックを再利用)
            const aspect = canvas.width / canvas.height;
            const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
            const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;

            // 3. アニメーション用の入力フォームを取得
            //    (idは各HTMLファイルに合わせてください)
            const targetXInput = document.getElementById('animate-target-x') || document.getElementById('animate-target-x-js');
            const targetYInput = document.getElementById('animate-target-y') || document.getElementById('animate-target-y-js');

            // 4. 取得した座標をフォームの入力値として設定
            if (targetXInput && targetYInput) {
                targetXInput.value = pointX.toExponential(10); // 指数表記で高精度に表示
                targetYInput.value = pointY.toExponential(10);
                console.log(`Clicked coordinates: (${pointX}, ${pointY})`);
            }
        });
        draw(); // 描画ループを開始

    </script>
</body>
</html>
