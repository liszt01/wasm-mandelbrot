<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot Explorer (Refactored)</title>
    <script src="https://cdn.jsdelivr.net/npm/decimal.js/decimal.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        canvas { display: block; }

        /* 全てのコントロールをまとめる親コンテナのスタイル */
        #controls-container {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex; /* Flexboxを有効化 */
            flex-direction: column; /* 子要素を縦に並べる */
            align-items: flex-start; /* 左端で揃える */
            gap: 15px; /* 各パネルの間に15pxの間隔を空ける */
        }

        /* 各操作パネルの共通スタイル */
        .control-panel {
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
        }

        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body>
    <canvas id="mandelbrot-canvas"></canvas>

    <div id="controls-container">
        <div id="info" class="control-panel">
            <h3>描画エンジン</h3>
            <span>JavaScript</span>
            <label class="toggle-switch">
                <input type="checkbox" id="engine-toggle" checked>
                <span class="slider"></span>
            </label>
            <span>Wasm</span>

            <div>
                <label>Center X:</label>
                <textarea id="center-x" rows="3">-0.75</textarea>
            </div>
            <div>
                <label>Center Y:</label>
                <textarea id="center-y" rows="3">0.0</textarea>
            </div>
            <div>
                <label>Scale:</label>
                <input type="number" id="scale" value="3.5">
            </div>
            <div>
                <label>Bailout Radius Squared:</label>
                <input type="number" id="bailout-radius-squared" value="100.0">
            </div>
            <div>
                <label>Max Iterations:</label>
                <input type="number" id="max-iterations" value="50">
            </div>
            <p id="render-time"></p>
        </div>
    </div>

    <script type="module">
        Decimal.set({ precision: 100 });

        const canvas = document.getElementById('mandelbrot-canvas');
        const ctx = canvas.getContext('2d');
        const engineToggle = document.getElementById('engine-toggle');
        const renderTimeEl = document.getElementById('render-time');

        // 中心座標
        let centerX = new Decimal(document.getElementById('center-x').value);
        let centerY = new Decimal(document.getElementById('center-y').value);

        let scale = parseFloat(document.getElementById('scale').value);
        const bailoutSq = parseFloat(document.getElementById('bailout-radius-squared').value);
        const maxIters = parseInt(document.getElementById('max-iterations').value, 10);

        let needsRedraw = true;
        let renderer = null;

        function updateCenterCoords() {
            document.getElementById('center-x').value = centerX.toString();
            document.getElementById('center-y').value = centerY.toString();
        }
        function updateScale() {
            document.getElementById('scale').value = scale;
        }

        const requestDraw = () => { needsRedraw = true; };

        const draw = () => {
            if (!needsRedraw || !renderer) {
                requestAnimationFrame(draw);
                return;
            }
            needsRedraw = false;
            // maxIterations = Math.floor(50 + Math.max(0, -Math.log10(scale) * 25));

            renderTimeEl.textContent = `描画中... (基準軌道を計算中)`;
            const orbit = renderer.calculate_references(centerX.toString(), centerY.toString(), maxIters);
            
            renderTimeEl.textContent = `描画中... (ピクセルを描画中)`;
            const startTime = performance.now();
            renderer.render_perturbation(ctx, canvas.width, canvas.height, scale, maxIters, orbit);
            const endTime = performance.now();

            renderTimeEl.textContent = `描画時間: ${(endTime - startTime).toFixed(2)} ms`;

            // zoomLevelEl.textContent = `ズーム: x${(1 / scale).toExponential(2)}`;
            // iterationsCountEl.textContent = `計算回数: ${maxIterations}`;

            requestAnimationFrame(draw);
        };
        
        // --- イベントリスナー ---
        async function switchRenderer() {
            const useWasm = engineToggle.checked;
            const rendererModule = useWasm ? await import('./renderer_wasm.js') : await import('./renderer_js.js');
            renderer = await rendererModule.initialize();
            requestDraw();
        }
        engineToggle.addEventListener('change', switchRenderer);
        
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', () => { resizeCanvas(); requestDraw(); });

        // ズーム
        canvas.addEventListener('wheel', event => {
            event.preventDefault();

            const zoomFactor = event.deltaY < 0 ? 0.90 : 1.10;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const aspect = canvas.width / canvas.height;

            const pointX = centerX.plus(
                new Decimal(mouseX / canvas.width - 0.5)
                    .times(scale)
                    .times(aspect)
            );
            const pointY = centerY.plus(
                new Decimal(mouseY / canvas.height - 0.5)
                    .times(scale)
            );

            scale *= zoomFactor;

            centerX = pointX.minus(pointX.minus(centerX).times(zoomFactor));
            centerY = pointY.minus(pointY.minus(centerY).times(zoomFactor));

            updateCenterCoords();
            updateScale();
            requestDraw();
        });
        
        // ドラッグ
        let isDragging = false, lastX, lastY;
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            const aspect = canvas.width / canvas.height;

            centerX = centerX.minus(
                new Decimal(dx / canvas.width)
                    .times(scale)
                    .times(aspect)
            );
            centerY = centerY.minus(
                new Decimal(dy / canvas.height)
                    .times(scale)
            );

            lastX = e.clientX;
            lastY = e.clientY;

            updateCenterCoords();
            requestDraw();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });

        
        // 中心座標・スケールなどの入力欄を監視
        document.getElementById('center-x').addEventListener('input', e => {
            centerX = new Decimal(e.target.value);
            requestDraw();
        });
        document.getElementById('center-y').addEventListener('input', e => {
            centerY = new Decimal(e.target.value);
            requestDraw();
        });
        document.getElementById('scale').addEventListener('input', e => {
            scale = parseFloat(e.target.value);
            requestDraw();
        });

        resizeCanvas();
        switchRenderer();
        draw();
    </script>
</body>
</html>
