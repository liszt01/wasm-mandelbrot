
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Wasm Mandelbrot Explorer</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; padding: 5px; background: rgba(0,0,0,0.5); border-radius: 5px; }
    </style>
</head>
<body>
    <canvas id="mandelbrot-canvas"></canvas>
    <div id="info">
        <p>マウスホイールでズーム、ドラッグで移動</p>
        <p id="zoom-level"></p>
        <p id="iterations-count"></p>
    </div>


    <div id="animation-controls" style="position: absolute; top: 10px; left: 200px; padding: 10px; background: rgba(0,0,0,0.7); border-radius: 5px;">
      <h3>アニメーションズーム</h3>
      <div>
        <label>ターゲット X:</label>
        <input type="text" id="animate-target-x" value="0.0">
      </div>
      <div>
        <label>ターゲット Y:</label>
        <input type="text" id="animate-target-y" value="0.0">
      </div>
      <div>
        <label>ズームステップ:</label>
        <input type="number" id="animate-steps" value="100" min="1">
      </div>
      <div>
        <label>ステップごとのズーム倍率:</label>
        <input type="number" id="animate-zoom-factor" value="0.98" min="0.5" max="0.999" step="0.001">
      </div>
      <button id="start-animation-button">アニメーション開始</button>
    </div>

    <script type="module">
        import init, { render } from './pkg/mandelbrot_zoom.js';

        async function main() {
            await init();

            const canvas = document.getElementById('mandelbrot-canvas');
            const ctx = canvas.getContext('2d');
            const zoomLevelEl = document.getElementById('zoom-level');
            const iterationsCountEl = document.getElementById('iterations-count');

            const resizeCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            window.addEventListener('resize', () => {
                resizeCanvas();
                requestDraw();
            });
            resizeCanvas();

            let centerX = -0.75;
            let centerY = 0.0;
            let scale = 3.5;
            let maxIterations = 50;

            let needsRedraw = true;
            const requestDraw = () => { needsRedraw = true; };

            const draw = () => {
                if (!needsRedraw) {
                    requestAnimationFrame(draw);
                    return;
                }
                needsRedraw = false;
                
                // ズームレベルに応じて計算回数を増やす
                maxIterations = Math.floor(50 + Math.max(0, -Math.log10(scale) * 25));

                const pixelData = render(canvas.width, canvas.height, centerX, centerY, scale, maxIterations);
                const imageData = new ImageData(new Uint8ClampedArray(pixelData), canvas.width, canvas.height);
                ctx.putImageData(imageData, 0, 0);

                zoomLevelEl.textContent = `ズーム: x${(1 / scale).toExponential(2)}`;
                iterationsCountEl.textContent = `計算回数: ${maxIterations}`;
                
                requestAnimationFrame(draw);
            };

            let animationIntervalId = null;
            let animationStep = 0;
            let targetCenterX = 0.0;
            let targetCenterY = 0.0;
            let totalSteps = 100;
            let zoomFactorPerStep = 0.98;

            const startAnimation = () => {
                targetCenterX = parseFloat(document.getElementById('animate-target-x').value);
                targetCenterY = parseFloat(document.getElementById('animate-target-y').value);
                totalSteps = parseInt(document.getElementById('animate-steps').value, 10);
                zoomFactorPerStep = parseFloat(document.getElementById('animate-zoom-factor').value);
                animationStep = 0;

                if (isNaN(targetCenterX) || isNaN(targetCenterY) || isNaN(totalSteps) || isNaN(zoomFactorPerStep) || totalSteps <= 0 || zoomFactorPerStep <= 0 || zoomFactorPerStep >= 1) {
                    alert("アニメーション設定が無効です。");
                    return;
                }

                if (animationIntervalId) {
                    clearInterval(animationIntervalId);
                    animationIntervalId = null;
                }

                animationIntervalId = setInterval(() => {
                    if (animationStep < totalSteps) {
                        // 現在のスケールと中心を少しずつターゲットに近づける
                        const aspect = canvas.width / canvas.height;
                        const deltaX = targetCenterX - centerX;
                        const deltaY = targetCenterY - centerY;

                        centerX += deltaX * 0.05; //  Lerp factor (調整可能)
                        centerY += deltaY * 0.05;

                        scale *= zoomFactorPerStep;
                        requestDraw();
                        animationStep++;
                    } else {
                        clearInterval(animationIntervalId);
                        animationIntervalId = null;
                        console.log("アニメーション終了");
                    }
                }, 30); // アニメーションのフレームレート (調整可能)
            };

            document.getElementById('start-animation-button').addEventListener('click', startAnimation);

            // ズーム処理
            canvas.addEventListener('wheel', event => {
                event.preventDefault();

                const zoomFactor = event.deltaY < 0 ? 0.9 : 1.1;

                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const aspect = canvas.width / canvas.height;
                const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
                const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;

                scale *= zoomFactor;

                centerX = pointX - (pointX - centerX) * zoomFactor;
                centerY = pointY - (pointY - centerY) * zoomFactor;

                requestDraw();
            });

            // ドラッグ（パン）処理
            let isDragging = false;
            let lastX, lastY;

            canvas.addEventListener('mousedown', event => {
                isDragging = true;
                lastX = event.clientX;
                lastY = event.clientY;
            });
            
            canvas.addEventListener('mousemove', event => {
                if (!isDragging) return;
                const dx = event.clientX - lastX;
                const dy = event.clientY - lastY;
                
                const aspect = canvas.width / canvas.height;
                centerX -= (dx / canvas.width) * scale * aspect;
                centerY -= (dy / canvas.height) * scale;
                
                lastX = event.clientX;
                lastY = event.clientY;
                requestDraw();
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            canvas.addEventListener('click', (event) => {
                // 1. マウスのキャンバス上の座標を取得
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // 2. キャンバス座標を複素平面上の座標に変換 (既存のロジックを再利用)
                const aspect = canvas.width / canvas.height;
                const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
                const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;

                // 3. アニメーション用の入力フォームを取得
                //    (idは各HTMLファイルに合わせてください)
                const targetXInput = document.getElementById('animate-target-x') || document.getElementById('animate-target-x-js');
                const targetYInput = document.getElementById('animate-target-y') || document.getElementById('animate-target-y-js');

                // 4. 取得した座標をフォームの入力値として設定
                if (targetXInput && targetYInput) {
                    targetXInput.value = pointX.toExponential(10); // 指数表記で高精度に表示
                    targetYInput.value = pointY.toExponential(10);
                    console.log(`Clicked coordinates: (${pointX}, ${pointY})`);
                }
            });           
            requestDraw();

            draw();
        }

        main();
    </script>
</body>
</html>
