<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot Explorer (Refactored)</title>
    <script src="https://cdn.jsdelivr.net/npm/decimal.js/decimal.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        canvas { display: block; }
        .control-panel { position: absolute; top: 10px; padding: 10px; background: rgba(0,0,0,0.7); border-radius: 5px; font-size: 12px; }
        .control-panel h3 { margin-top: 0; }
        .control-panel div { margin-bottom: 5px; }
        .control-panel label { display: block; margin-bottom: 2px; }
        .control-panel input, .control-panel textarea, .control-panel button { width: calc(100% - 10px); box-sizing: border-box; }
        #info { left: 10px; }
        #renderer-toggle { left: 250px; }
        #pert-controls { left: 500px; width: 300px; }

        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body>
    <canvas id="mandelbrot-canvas"></canvas>

    <div id="info" class="control-panel">
        <h2 id="renderer-title">Wasm版</h2>
        <p>マウスホイールでズーム、ドラッグで移動</p>
        <p id="zoom-level"></p>
        <p id="iterations-count"></p>
        <p id="render-time"></p>
    </div>

    <div id="renderer-toggle" class="control-panel">
        <h3>描画エンジン</h3>
        <span>JavaScript</span>
        <label class="toggle-switch">
            <input type="checkbox" id="engine-toggle" checked>
            <span class="slider"></span>
        </label>
        <span>Wasm</span>
    </div>
    
    <div id="pert-controls" class="control-panel">
        <h3>摂動論 (Perturbation)</h3>
        <div>
            <label>Center X (高精度):</label>
            <textarea id="pert-center-x" rows="3">-1.768610493014677074503175653270226520239677907588665494812359766720721863405719772</textarea>
        </div>
        <div>
            <label>Center Y (高精度):</label>
            <textarea id="pert-center-y" rows="3">0.001266613503868717702066411192242601576193940560471409839484404683951701639387836214</textarea>
        </div>
        <div>
            <label>Scale:</label>
            <input type="text" id="pert-scale" value="1e-20">
        </div>
         <div>
            <label>Max Iterations:</label>
            <input type="number" id="pert-max-iter" value="20000">
        </div>
        <button id="pert-render-button">摂動論で描画</button>
    </div>

    <script type="module">
        // 状態管理とUIロジック
        const canvas = document.getElementById('mandelbrot-canvas');
        const ctx = canvas.getContext('2d');
        const zoomLevelEl = document.getElementById('zoom-level');
        const iterationsCountEl = document.getElementById('iterations-count');
        const renderTimeEl = document.getElementById('render-time');
        const engineToggle = document.getElementById('engine-toggle');
        const rendererTitle = document.getElementById('renderer-title');

        let centerX = -0.75, centerY = 0.0, scale = 3.5, maxIterations = 50;
        let needsRedraw = true;
        let renderer = null;

        const requestDraw = () => { needsRedraw = true; };

        // 通常描画のループ
        const draw = () => {
            if (!needsRedraw || !renderer || renderer.isPerturbation) { // 摂動モードでは自動更新しない
                requestAnimationFrame(draw);
                return;
            }
            needsRedraw = false;
            maxIterations = Math.floor(50 + Math.max(0, -Math.log10(scale) * 25));

            const startTime = performance.now();
            // 通常レンダラーを呼び出す（存在すれば）
            if (typeof renderer.render === 'function') {
                renderer.render(ctx, canvas.width, canvas.height, centerX, centerY, scale, maxIterations);
            }
            const endTime = performance.now();

            zoomLevelEl.textContent = `ズーム: x${(1 / scale).toExponential(2)}`;
            iterationsCountEl.textContent = `計算回数: ${maxIterations}`;
            renderTimeEl.textContent = `描画時間: ${(endTime - startTime).toFixed(2)} ms`;
            requestAnimationFrame(draw);
        };
        
        async function switchRenderer() {
            const useWasm = engineToggle.checked;
            rendererTitle.textContent = useWasm ? "Wasm版" : "JavaScript版";
            // 摂動論を実装したので、通常レンダラーのモジュール名を変更
            const rendererModule = useWasm ? await import('./renderer_wasm.js') : await import('./renderer_js.js');
            renderer = await rendererModule.initialize();
            
            // isPerturbationプロパティで通常モードか判断
            renderer.isPerturbation = false; 
            
            // 初回描画
            requestDraw();
        }
        engineToggle.addEventListener('change', switchRenderer);
        
        // --- 共通のイベントリスナー ---
        const resizeCanvas = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
        window.addEventListener('resize', () => { resizeCanvas(); requestDraw(); });

        canvas.addEventListener('wheel', event => {
            if (renderer && renderer.isPerturbation) return; // 摂動モードでは無効
            event.preventDefault();
            const zoomFactor = event.deltaY < 0 ? 0.90 : 1.10;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left, mouseY = event.clientY - rect.top;
            const aspect = canvas.width / canvas.height;
            const pointX = centerX + (mouseX / canvas.width - 0.5) * scale * aspect;
            const pointY = centerY + (mouseY / canvas.height - 0.5) * scale;
            scale *= zoomFactor;
            centerX = pointX - (pointX - centerX) * zoomFactor;
            centerY = pointY - (pointY - centerY) * zoomFactor;
            requestDraw();
        });
        
        let isDragging = false, lastX, lastY;
        canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
        canvas.addEventListener('mousemove', e => {
            if (!isDragging || (renderer && renderer.isPerturbation)) return;
            const dx = e.clientX - lastX, dy = e.clientY - lastY;
            const aspect = canvas.width / canvas.height;
            centerX -= (dx / canvas.width) * scale * aspect;
            centerY -= (dy / canvas.height) * scale;
            lastX = e.clientX; lastY = e.clientY;
            requestDraw();
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        // 摂動論用の描画イベント
        document.getElementById('pert-render-button').addEventListener('click', async () => {
            if (!renderer) {
                alert("レンダラーが初期化されていません。");
                return;
            }
            if (typeof renderer.calculate_references !== 'function') {
                alert("現在のレンダラーは摂動論をサポートしていません。");
                return;
            }
            renderer.isPerturbation = true; // 摂動モードに設定

            console.log("摂動論描画を開始します...");
            renderTimeEl.textContent = `描画中... (基準軌道を計算中)`;
            
            const centerXStr = document.getElementById('pert-center-x').value;
            const centerYStr = document.getElementById('pert-center-y').value;
            const scaleValue = parseFloat(document.getElementById('pert-scale').value);
            const maxItersValue = parseInt(document.getElementById('pert-max-iter').value, 10);

            // 基準軌道計算
            const orbit = renderer.calculate_references(centerXStr, centerYStr, maxItersValue);
            
            console.log(`基準軌道の計算完了。${orbit.length / 2} ステップ`);
            renderTimeEl.textContent = `描画中... (ピクセルを描画中)`;

            // 摂動描画
            const startTime = performance.now();
            renderer.render_perturbation(ctx, canvas.width, canvas.height, scaleValue, maxItersValue, orbit);
            const endTime = performance.now();
            renderTimeEl.textContent = `摂動描画完了: ${(endTime - startTime).toFixed(2)} ms`;
            console.log("摂動論描画完了");
        });

        // 初期化処理
        resizeCanvas();
        switchRenderer();
        draw();
    </script>
</body>
</html>
